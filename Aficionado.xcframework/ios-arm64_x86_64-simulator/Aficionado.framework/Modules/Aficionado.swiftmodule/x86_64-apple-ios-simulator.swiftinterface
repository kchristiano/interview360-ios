// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios17.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Aficionado
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum HTTPStatusCode : Swift.Int, Swift.Error {
  public enum ResponseType {
    case informational
    case success
    case redirection
    case clientError
    case serverError
    case undefined
    public var codes: [Aficionado.HTTPStatusCode] {
      get
    }
    public static func == (a: Aficionado.HTTPStatusCode.ResponseType, b: Aficionado.HTTPStatusCode.ResponseType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case `continue`
  case switchingProtocols
  case processing
  case ok
  case created
  case accepted
  case nonAuthoritativeInformation
  case noContent
  case resetContent
  case partialContent
  case multiStatus
  case alreadyReported
  case imUsed
  case multipleChoices
  case movedPermanently
  case found
  case seeOther
  case notModified
  case useProxy
  case switchProxy
  case temporaryRedirect
  case permanentRedirect
  case badRequest
  case unauthorized
  case paymentRequired
  case forbidden
  case notFound
  case methodNotAllowed
  case notAcceptable
  case proxyAuthenticationRequired
  case requestTimeout
  case conflict
  case gone
  case lengthRequired
  case preconditionFailed
  case payloadTooLarge
  case URITooLong
  case unsupportedMediaType
  case rangeNotSatisfiable
  case expectationFailed
  case teapot
  case pageExpired
  case misdirectedRequest
  case unprocessableEntity
  case locked
  case failedDependency
  case upgradeRequired
  case preconditionRequired
  case tooManyRequests
  case requestHeaderFieldsTooLarge
  case noResponse
  case unavailableForLegalReasons
  case SSLCertificateError
  case SSLCertificateRequired
  case HTTPRequestSentToHTTPSPort
  case clientClosedRequest
  case internalServerError
  case notImplemented
  case badGateway
  case serviceUnavailable
  case gatewayTimeout
  case HTTPVersionNotSupported
  case variantAlsoNegotiates
  case insufficientStorage
  case loopDetected
  case notExtended
  case networkAuthenticationRequired
  public var responseType: Aficionado.HTTPStatusCode.ResponseType {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Foundation.HTTPURLResponse {
  public var httpStatusCode: Aficionado.HTTPStatusCode? {
    get
  }
}
public protocol NetworkManaging {
  #if compiler(>=5.3) && $AsyncAwait
  func fetchFamousArtworkPayload() async throws -> Foundation.Data
  #endif
  func fetchFamousArtworkPayload(_ completion: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  init(configuration: any Aficionado.NetworkConfigurable)
}
final public class NetworkManager : Aficionado.NetworkManaging {
  final public var configuration: any Aficionado.NetworkConfigurable {
    get
  }
  required public init(configuration: any Aficionado.NetworkConfigurable)
  #if compiler(>=5.3) && $AsyncAwait
  final public func fetchFamousArtworkPayload() async throws -> Foundation.Data
  #endif
  @available(*, deprecated, renamed: "fetchFamousArtworkPayload()", message: "This will be removed! Use the async throws variant of this function")
  final public func fetchFamousArtworkPayload(_ completion: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum Stability {
  case excellent
  case strong
  case poor
  case unavailable
  public static func == (a: Aficionado.Stability, b: Aficionado.Stability) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ViewsError : Swift.Error {
  case failedToMakeRequest
  public static func == (a: Aficionado.ViewsError, b: Aficionado.ViewsError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ViewsService {
  public init()
  @objc deinit
  final public func viewsStream(itemid: Swift.String) throws -> Combine.AnyPublisher<Swift.Int, Swift.Never>
}
public protocol NetworkConfigurable {
  var stability: Aficionado.Stability { get }
}
public struct NetworkConfiguration : Aficionado.NetworkConfigurable {
  public let stability: Aficionado.Stability
  public init(stability: Aficionado.Stability = .excellent)
}
public enum ArtworkFetchError : Swift.Error {
  case invalidImageName
  public static func == (a: Aficionado.ArtworkFetchError, b: Aficionado.ArtworkFetchError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ArtworkProviding {
  #if compiler(>=5.3) && $AsyncAwait
  func fetchImage(url: Foundation.URL) async throws -> Foundation.Data
  #endif
}
final public class ArtworkProvider : Aficionado.ArtworkProviding {
  public init()
  #if compiler(>=5.3) && $AsyncAwait
  final public func fetchImage(url: Foundation.URL) async throws -> Foundation.Data
  #endif
  @objc deinit
}
extension Aficionado.HTTPStatusCode : Swift.Equatable {}
extension Aficionado.HTTPStatusCode : Swift.Hashable {}
extension Aficionado.HTTPStatusCode : Swift.RawRepresentable {}
extension Aficionado.HTTPStatusCode.ResponseType : Swift.Equatable {}
extension Aficionado.HTTPStatusCode.ResponseType : Swift.Hashable {}
extension Aficionado.Stability : Swift.Equatable {}
extension Aficionado.Stability : Swift.Hashable {}
extension Aficionado.ViewsError : Swift.Equatable {}
extension Aficionado.ViewsError : Swift.Hashable {}
extension Aficionado.ArtworkFetchError : Swift.Equatable {}
extension Aficionado.ArtworkFetchError : Swift.Hashable {}
